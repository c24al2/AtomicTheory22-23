Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/intake/Intake.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.intake;\n\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.roadrunner.control.PIDCoefficients;\nimport com.acmerobotics.roadrunner.control.PIDFController;\nimport com.acmerobotics.roadrunner.profile.MotionProfile;\nimport com.acmerobotics.roadrunner.profile.MotionProfileGenerator;\nimport com.acmerobotics.roadrunner.profile.MotionState;\nimport com.qualcomm.hardware.lynx.LynxModule;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\nimport com.qualcomm.robotcore.hardware.Servo;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\nimport com.qualcomm.robotcore.util.ElapsedTime;\n\nimport org.firstinspires.ftc.teamcode.util.LynxModuleUtil;\n\n// https://github.com/NoahBres/VelocityPIDTuningTutorial/blob/master/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/SampleLinkedPIDUse.java\n@Config\npublic class Intake {\n    public static PIDCoefficients INTAKE_PID = new PIDCoefficients(.009, 0, 0.0002);\n    public static double kV = 0;\n    public static double kA = 0;\n    public static double kStatic = 0;\n\n    public static double MOTION_PROFILE_RECREATION_THRESHOLD = 2; // Only recreate the motion profile if target position changes by this many ticks\n\n    public static double MAX_LIFT_HEIGHT = 1800; // In ticks\n\n    public static double GRAVITY_ACCEL = 900; // Constant feedforward acceleration (in ticks/sec/sec) to counteract the lift\n    public static double MAX_VEL = 62000;\n    public static double MAX_ACCEL = 2000;\n    public static double MAX_JERK = 0;  // Jerk isn't used if it's 0, but it might end up being necessary\n\n    public ElapsedTime timer;\n\n    public DcMotorEx intake;\n    public Servo clawServo;\n\n    private PIDFController controller;\n    public MotionProfile motionProfile;\n\n    public double power = 0;\n\n    public Intake(HardwareMap hardwareMap) {\n        LynxModuleUtil.ensureMinimumFirmwareVersion(hardwareMap);\n\n        timer = new ElapsedTime();\n\n        intake = hardwareMap.get(DcMotorEx.class, \"intake\");\n        clawServo = hardwareMap.get(Servo.class, \"clawServo\");\n\n        intake.setDirection(DcMotor.Direction.REVERSE);\n        intake.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        intake.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        intake.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n\n        // Turns on bulk reading\n        for (LynxModule module : hardwareMap.getAll(LynxModule.class)) {\n            module.setBulkCachingMode(LynxModule.BulkCachingMode.AUTO);\n        }\n\n        controller = new PIDFController(INTAKE_PID, kV, kA, kStatic);\n        setTargetPosition(intake.getCurrentPosition());\n    }\n\n    public void openClaw() {\n        clawServo.setPosition(1.0);\n    }\n    public void closeClaw(){\n        clawServo.setPosition(0.8);\n    }\n\n    public double getTargetPosition() {\n        return motionProfile.end().getX();\n    }\n\n    public void setTargetPosition(double targetPosition) {\n        // Add bounds so that the lift can not go too high or too low\n        if (targetPosition < 0) {\n            targetPosition = 0;\n        } else if (targetPosition > MAX_LIFT_HEIGHT) {\n            targetPosition = MAX_LIFT_HEIGHT;\n        }\n\n        if (motionProfile == null || Math.abs(motionProfile.end().getX() - targetPosition) > MOTION_PROFILE_RECREATION_THRESHOLD) {\n            motionProfile = MotionProfileGenerator.generateSimpleMotionProfile(\n                    new MotionState(intake.getCurrentPosition(), intake.getVelocity(), 0),\n                    new MotionState(targetPosition, 0, 0),\n                    MAX_VEL,\n                    MAX_ACCEL,\n                    MAX_JERK\n            );\n\n            timer.reset();\n        }\n    }\n\n    public void setRelativeTargetPosition(double deltaTargetPosition) {\n        double newTargetPosition = getTargetPosition() + deltaTargetPosition;\n        setTargetPosition(newTargetPosition);\n    }\n\n    public void followMotionProfile() {\n        MotionState state = motionProfile.get(timer.time());\n\n        controller.setTargetPosition(state.getX());\n        controller.setTargetVelocity(state.getV());\n        controller.setTargetAcceleration(state.getA() + GRAVITY_ACCEL);\n\n        power = controller.update(intake.getCurrentPosition(), intake.getVelocity());\n        intake.setPower(power);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/intake/Intake.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/intake/Intake.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/intake/Intake.java	(revision 951bd1ec448ddf0ab209ebc433b404f834a5dbee)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/intake/Intake.java	(date 1675280008041)
@@ -65,10 +65,10 @@
     }
 
     public void openClaw() {
-        clawServo.setPosition(1.0);
+        clawServo.setPosition(0.2);
     }
     public void closeClaw(){
-        clawServo.setPosition(0.8);
+        clawServo.setPosition(0.7);
     }
 
     public double getTargetPosition() {
