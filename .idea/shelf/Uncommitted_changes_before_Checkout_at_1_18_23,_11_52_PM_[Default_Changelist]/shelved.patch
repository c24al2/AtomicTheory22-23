Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RobotHardware.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2017 FIRST. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted (subject to the limitations in the disclaimer below) provided that\n * the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice, this list\n * of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright notice, this\n * list of conditions and the following disclaimer in the documentation and/or\n * other materials provided with the distribution.\n *\n * Neither the name of FIRST nor the names of its contributors may be used to endorse or\n * promote products derived from this software without specific prior written permission.\n *\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\n * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.firstinspires.ftc.teamcode;\n\nimport com.qualcomm.hardware.bosch.BNO055IMU;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\nimport com.qualcomm.robotcore.hardware.PIDCoefficients;\nimport com.qualcomm.robotcore.hardware.Servo;\nimport com.qualcomm.robotcore.util.ElapsedTime;\n\nimport org.firstinspires.ftc.robotcore.external.Telemetry;\nimport org.firstinspires.ftc.teamcode.pathfinding.Node;\nimport org.firstinspires.ftc.teamcode.pid.MotorPID;\nimport org.firstinspires.ftc.teamcode.vision.ParkingPosition;\nimport org.firstinspires.ftc.teamcode.vision.AprilTagPipeline;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class RobotHardware {\n    /* Public OpMode members. */\n    public DcMotorEx W1;\n    public DcMotorEx W2;\n    public DcMotorEx W3;\n    public DcMotorEx intake;\n    public Servo intakeServo;\n    private BNO055IMU imu;\n    HardwareMap hardwareMap;\n    Telemetry telemetry;\n    private AprilTagPipeline aprilTagPipeline;\n\n\n    /* Constructor */\n\n    public RobotHardware(HardwareMap hardwareMap, Telemetry telemetry) {\n        this.hardwareMap = hardwareMap;\n        this.telemetry = telemetry;\n\n        // Define and initialize motors\n        W1 = hardwareMap.get(DcMotorEx.class, \"fr\");\n        W2 = hardwareMap.get(DcMotorEx.class, \"fl\");\n        W3 = hardwareMap.get(DcMotorEx.class, \"back\");\n        W1.setDirection(DcMotor.Direction.FORWARD);\n        W2.setDirection(DcMotor.Direction.FORWARD);\n        W3.setDirection(DcMotor.Direction.FORWARD);\n        //set zero power behaviors for each motor\n        W1.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        W2.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        W3.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n\n        // Set all motors to zero power\n        W1.setPower(0);\n        W2.setPower(0);\n        W3.setPower(0);\n\n        W1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        W1.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        W2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        W2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        W3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        W3.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n\n        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\n        parameters.mode = BNO055IMU.SensorMode.IMU;\n        parameters.angleUnit = BNO055IMU.AngleUnit.RADIANS;\n        parameters.accelUnit = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\n        parameters.loggingEnabled = false;\n        imu.initialize(parameters);\n\n\n//        telemetry.addData(\"Camera status:\", \"waiting\");\n//        telemetry.update();\n//        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\"cameraMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n//        webcam = OpenCvCameraFactory.getInstance().createWebcam(hardwareMap.get(WebcamName.class, \"Webcam 1\"), cameraMonitorViewId);\n//        aprilTagPipeline = new AprilTagPipeline();\n//        webcam.setPipeline(aprilTagPipeline);\n//        webcam.setMillisecondsPermissionTimeout(2500);\n//        webcam.openCameraDeviceAsync(new OpenCvCamera.AsyncCameraOpenListener() {\n//            @Override\n//            public void onOpened() {\n//                webcam.startStreaming(Constants.CAM_WIDTH, Constants.CAM_HEIGHT, OpenCvCameraRotation.UPRIGHT);\n//                //telemetry.addData(\"Camera status:\", \"initialized\");\n//                telemetry.update();\n//            }\n//\n//            @Override\n//            public void onError(int errorCode) {\n//                // This will be called if the camera could not be opened\n//            }\n//        });\n//        while(aprilTagPipeline.parkingPosition == ParkingPosition.UNKNOWN){\n//            telemetry.addData(\"camera ready?\", \"true\");\n//            telemetry.addData(\"pipeline chosen\", \"April Tag Pipeline\");\n//            telemetry.update();\n//        }\n    }\n\n//    public void lift(double Distance, double timeout, double power){\n//        ElapsedTime timer = new ElapsedTime();\n//        timer.reset();\n//        intake.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n//        int distance = (int)Math.round(Distance);\n//        intake.setTargetPosition(distance);\n//        intake.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n//        intake.setPower(power);\n//        while (intake.isBusy() && timer.milliseconds() < timeout) {\n//        }\n//        stopDrive();\n//    }\n//\n   public void servoSetZero() {\n       intakeServo.setPosition(.77);\n   }\n\n\n    // Generate the table describing the trajectory to follow\n\n\n    // at every step in your PID loop, you advance one time index in your traj[] array.\n\n    // to get x,y from traj, first find the index in the list where you are (given by the time), and then x = traj[1][i], y = traj[2][i]\n    public void PIDAStarRevamp(List<Node> points){\n        // create three arrays (2d) that form one large array\n        //take 5 seconds (time the trajectory should take) cut that into 100 intervals\n        //populate the first array with a list of times in those intervals\n        //generate your x-list take your final x position and subtract your initial x poition and divide by the number of steps you want to have\n        W1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        W1.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        W2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        W2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        W3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        W3.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n\n        double loopTime = 0.05;\n        double time = loopTime*points.size();\n\n\n        PIDCoefficients positionPIDConstants = new PIDCoefficients(1, 0, 0);\n        PIDCoefficients velocityPIDConstants = new PIDCoefficients(1, 0, 0);\n\n        MotorPID W1PID = new MotorPID(W1, positionPIDConstants, velocityPIDConstants, telemetry);\n        MotorPID W2PID = new MotorPID(W2, positionPIDConstants, velocityPIDConstants, telemetry);\n        MotorPID W3PID = new MotorPID(W3, positionPIDConstants, velocityPIDConstants, telemetry);\n\n        //create ArrayLists to hold the variables we want to keep track of\n        ArrayList<Double> times = new ArrayList<>();\n        ArrayList<Double> xcoords = new ArrayList<>();\n        ArrayList<Double> ycoords = new ArrayList<>();\n\n\n        // calculate the number of steps we should have based on the timeout and the runtime of the loop (usually under .15)\n        double numSteps = points.size() - 1;\n        for (int i = 0; i <= points.size()-1; i++) {\n            double currentTime = time/numSteps*i;\n            times.add(currentTime); // time generation\n            Node point = points.get(i);\n            double xValue = point.getXCM() * 10;\n            xcoords.add(xValue); // assume constant velocity\n            double yValue = point.getYCM() * 10;\n            ycoords.add(yValue);\n            // add telemetry so we know what trajectory the robot is trying to follow\n            if (i % (numSteps/10) == 0) {\n                telemetry.addData(\"Point\", i);\n                telemetry.addData(\"times\", times.get(i));\n                telemetry.addData(\"xcoords\", xcoords.get(i));\n                telemetry.addData(\"ycoords\", ycoords.get(i));\n                telemetry.addData(\"\", \"\");\n            }\n        }\n        xcoords.add(xcoords.get(points.size() - 1));\n        ycoords.add(ycoords.get(points.size() - 1));\n\n        telemetry.update();\n\n        ElapsedTime timer = new ElapsedTime();\n        timer.reset();\n        // stall time\n        while(timer.seconds() < 8){}\n        double evaluationTime = 0;\n        // track what index you're looking at\n        int loopRuns = 0;\n        timer.reset();\n        double W1AStarPreviousIdealEncoderPosition = 0;\n        double W2AStarPreviousIdealEncoderPosition = 0;\n        double W3AStarPreviousIdealEncoderPosition = 0;\n        double W1IdealEncoderVelocity;\n        double W2IdealEncoderVelocity;\n        double W3IdealEncoderVelocity;\n        while (timer.seconds() < time){\n            double startTime = timer.seconds();\n\n            evaluationTime = evaluationTime + time/numSteps*loopRuns;\n\n            double m = (xcoords.get(loopRuns + 1) - xcoords.get(loopRuns))/(ycoords.get(loopRuns + 1) - xcoords.get(loopRuns));\n            double xAngle = Math.atan(m);\n            double thetaW1 = (2*Math.PI)/3 - xAngle;\n            double thetaW2 = (4*Math.PI)/3 - xAngle;\n            double thetaW3 = (2*Math.PI) - xAngle;\n            double x_i = Math.sqrt((xcoords.get(loopRuns + 1) - xcoords.get(loopRuns)) * (xcoords.get(loopRuns + 1) - xcoords.get(loopRuns)) + (ycoords.get(loopRuns + 1) - ycoords.get(loopRuns)) * (ycoords.get(loopRuns + 1) - ycoords.get(loopRuns)));\n            double W1EncoderScalar = x_i/Math.cos(thetaW1);\n            double W2EncoderScalar = x_i/Math.cos(thetaW2);\n            double W3EncoderScalar = x_i/Math.cos(thetaW3);\n            double W1AStarIdealEncoderPositionChange = W1EncoderScalar * 96 * Math.PI * 537.7;\n            double W2AStarIdealEncoderPositionChange = W2EncoderScalar * 96 * Math.PI * 537.7;\n            double W3AStarIdealEncoderPositionChange = W3EncoderScalar * 96 * Math.PI * 537.7;\n            double W1AStarIdealEncoderPosition = W1AStarIdealEncoderPositionChange + W1AStarPreviousIdealEncoderPosition;\n            double W2AStarIdealEncoderPosition = W2AStarIdealEncoderPositionChange + W2AStarPreviousIdealEncoderPosition;\n            double W3AStarIdealEncoderPosition = W3AStarIdealEncoderPositionChange + W3AStarPreviousIdealEncoderPosition;\n\n            telemetry.addData(\"W1IdealEncoderPosition\", W1AStarIdealEncoderPosition);\n            telemetry.addData(\"W2IdealEncoderPosition\", W2AStarIdealEncoderPosition);\n            telemetry.addData(\"W3IdealEncoderPosition\", W3AStarIdealEncoderPosition);\n\n                // take the lookahead and subtract the current, divide by time to find the magnitude of the velocity vector, named here simply as velocity\n                //must use already converted to encoder counts\n            W1IdealEncoderVelocity = (W1AStarIdealEncoderPositionChange)/(loopTime);\n            W2IdealEncoderVelocity = (W2AStarIdealEncoderPositionChange)/(loopTime);\n            W3IdealEncoderVelocity = (W3AStarIdealEncoderPositionChange)/(loopTime);\n\n            // plug in velocity values for velocity of each motor given by the matri\n\n            telemetry.addData(\"W1IdealEncoderVelocity\", W1IdealEncoderVelocity);\n            telemetry.addData(\"W2IdealEncoderVelocity\", W2IdealEncoderVelocity);\n            telemetry.addData(\"W3IdealEncoderVelocity\", W3IdealEncoderVelocity);\n\n            W1PID.step(evaluationTime, W1AStarIdealEncoderPosition, W1IdealEncoderVelocity);\n            W2PID.step(evaluationTime, W2AStarIdealEncoderPosition, W2IdealEncoderVelocity);\n            W3PID.step(evaluationTime, W3AStarIdealEncoderPosition, W3IdealEncoderVelocity);\n\n            telemetry.addData(\"Finished while loop in: \", timer.seconds()-startTime);\n\n            telemetry.update();\n            W1AStarPreviousIdealEncoderPosition = W1AStarIdealEncoderPosition;\n            W2AStarPreviousIdealEncoderPosition = W2AStarIdealEncoderPosition;\n            W3AStarPreviousIdealEncoderPosition = W3AStarIdealEncoderPosition;\n            while(timer.seconds() - startTime < loopTime){}\n            loopRuns = loopRuns + 1;\n        }\n    }\n\n    @Deprecated\n    public void PIDQuadraticTrajectoryController(double trajectoryA, double trajectoryB, double trajectoryC, double timeout, double x_final){\n        // create three arrays (2d) that form one large array\n        //take 5 seconds (time the trajectory should take) cut that into 100 intervals\n        //populate the first array with a list of times in those intervals\n        //generate your x-list take your final x position and subtract your initial x poition and divide by the number of steps you want to have\n\n\n        PIDCoefficients positionPIDConstants = new PIDCoefficients(1, 0, 0);\n        PIDCoefficients velocityPIDConstants = new PIDCoefficients(1, 0, 0);\n\n        MotorPID W1PID = new MotorPID(W1, positionPIDConstants, velocityPIDConstants, telemetry);\n        MotorPID W2PID = new MotorPID(W2, positionPIDConstants, velocityPIDConstants, telemetry);\n        MotorPID W3PID = new MotorPID(W3, positionPIDConstants, velocityPIDConstants, telemetry);\n\n        //create ArrayLists to hold the variables we want to keep track of\n        ArrayList<Double> times = new ArrayList<>();\n        ArrayList<Double> xcoords = new ArrayList<>();\n        ArrayList<Double> ycoords = new ArrayList<>();\n        ArrayList<Double> yVelocities = new ArrayList<>();\n        ArrayList<Double> xVelocities = new ArrayList<>();\n\n        double tf = timeout;\n        double xf = x_final;\n        // calculate the number of steps we should have based on the timeout and the runtime of the loop (usually under .15)\n        double doublenumSteps = tf/0.15;\n        int  numSteps = (int) Math.round (doublenumSteps);\n        for (int i = 0; i <= numSteps; i++) {\n            double time = tf/numSteps*i;\n            times.add(time); // time generation\n            double xValue = (xf)/numSteps*i;\n            xcoords.add(xValue); // assume constant velocity\n            double yValue = (trajectoryA*xValue*xValue + trajectoryB*xValue + trajectoryC);\n            ycoords.add(yValue);\n            // add telemetry so we know what trajectory the robot is trying to follow\n            if (i % (numSteps/10) == 0) {\n                telemetry.addData(\"Point\", i);\n                telemetry.addData(\"times\", times.get(i));\n                telemetry.addData(\"xcoords\", xcoords.get(i));\n                telemetry.addData(\"ycoords\", ycoords.get(i));\n                telemetry.addData(\"\", \"\");\n            }\n        }\n\n\n        for (int i = 0; i < numSteps; i++) {\n            // take the lookahead and subtract the current, divide by time to find the magnitude of the velocity vector, named here simply as velocity\n            double currentX = xcoords.get(i);\n            double currentY = ycoords.get(i);\n            double lookaheadX = xcoords.get(i+1);\n            double lookaheadY = ycoords.get(i+1);\n            double yVelocity = (lookaheadY - currentY)/(tf/numSteps);\n            double xVelocity = (lookaheadX - currentX)/(tf/numSteps);\n            yVelocities.add(yVelocity);\n            xVelocities.add(xVelocity);\n            if (i % (numSteps/10) == 0) {\n                telemetry.addData(\"yVelocity\", yVelocities.get(i));\n                telemetry.addData(\"xVelocity\", xVelocities.get(i));\n            }\n        }\n        yVelocities.add(0.0);\n        xVelocities.add(0.0);\n\n        telemetry.update();\n\n        ElapsedTime timer = new ElapsedTime();\n        timer.reset();\n        while(timer.seconds() < 8){}\n\n        ElapsedTime internaltimer = new ElapsedTime();\n        double evaluationTime = 0;\n        // track what index you're looking at\n        int loopRuns = 0;\n        timer.reset();\n        while (timer.seconds() < timeout){\n            internaltimer.reset();\n            evaluationTime = evaluationTime + tf/numSteps*loopRuns;\n\n            //xcoords and ycoords are in encoder counts\n            double parametrizedLookAheadX = xcoords.get(loopRuns);\n            double parametrizedLookAheadY = ycoords.get(loopRuns);\n\n            // plug in generated x and y into the matrix for encoder positions\n            double W1IdealEncoderPosition = -1.0/3 * parametrizedLookAheadX + .58 * parametrizedLookAheadY;\n            double W2IdealEncoderPosition = -1.0/3 * parametrizedLookAheadX - .58 * parametrizedLookAheadY;\n            double W3IdealEncoderPosition = 2.0/3 * parametrizedLookAheadX;\n\n            telemetry.addData(\"W1IdealEncoderPosition\", W1IdealEncoderPosition);\n            telemetry.addData(\"W2IdealEncoderPosition\", W2IdealEncoderPosition);\n            telemetry.addData(\"W3IdealEncoderPosition\", W3IdealEncoderPosition);\n\n            // plug in velocity values for velocity of each motor given by the matrix\n            double W1IdealEncoderVelocity = -1.0/3 * xVelocities.get(loopRuns) + .58 * yVelocities.get(loopRuns);\n            double W2IdealEncoderVelocity = -1.0/3 * xVelocities.get(loopRuns) - .58 * yVelocities.get(loopRuns);\n            double W3IdealEncoderVelocity = 2.0/3 * xVelocities.get(loopRuns);\n\n            telemetry.addData(\"W1IdealEncoderVelocity\", W1IdealEncoderVelocity);\n            telemetry.addData(\"W2IdealEncoderVelocity\", W2IdealEncoderVelocity);\n            telemetry.addData(\"W3IdealEncoderVelocity\", W3IdealEncoderVelocity);\n\n            W1PID.step(evaluationTime, W1IdealEncoderPosition, W1IdealEncoderVelocity);\n            W2PID.step(evaluationTime, W2IdealEncoderPosition, W2IdealEncoderVelocity);\n            W3PID.step(evaluationTime, W3IdealEncoderPosition, W3IdealEncoderVelocity);\n\n            loopRuns = loopRuns + 1;\n\n            while(internaltimer.seconds() < 0.15){}\n        }\n    }\n    // idea for the constant velocity motion:\n    // take the integral of the function\n\n    public void driveRightSide(double distance, double timeout, double power){\n        ElapsedTime timer = new ElapsedTime();\n        timer.reset();\n        //reset encoders\n        W1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        W2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        W3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        double W1Target = -.5;\n        double W2Target = -.5;\n        double W3Target = 1;\n        double W1Encoder = W1Target * distance;\n        double W2Encoder = W2Target * distance;\n        double W3Encoder = W3Target * distance;\n        int intW1Encoder = (int)Math.round(W1Encoder);\n        int intW2Encoder = (int)Math.round(W2Encoder);\n        int intW3Encoder = (int)Math.round(W3Encoder);\n\n        W1.setTargetPosition(intW1Encoder);\n        W2.setTargetPosition(intW2Encoder);\n        W3.setTargetPosition(intW3Encoder);\n        W1.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        W2.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        W3.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n\n        double proportion = Math.max(Math.max(Math.abs(W1Encoder), Math.abs(W2Encoder)), Math.max(Math.abs(W2Encoder), Math.abs(W3Encoder)));\n        W1.setPower(power * W1Encoder/ proportion);\n        W2.setPower(power * W2Encoder/ proportion);\n        W3.setPower(power * W3Encoder/ proportion);\n        //wait until the motors finish or time expires\n        //noinspection StatementWithEmptyBody\n        while ((W1.isBusy() || W2.isBusy() || W3.isBusy()) && timer.milliseconds() < timeout) {\n        }\n        stopDrive();\n        }\n\n    public void driveRightSideMillimeters(double distanceInMillimeters, double timeout, double power){\n        ElapsedTime timer = new ElapsedTime();\n        timer.reset();\n\n        double distance = distanceInMillimeters * 1.78288404788;\n        //reset encoders\n        W1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        W2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        W3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        double W1Target = -.5;\n        double W2Target = -.5;\n        double W3Target = 1;\n        double W1Encoder = W1Target * distance;\n        double W2Encoder = W2Target * distance;\n        double W3Encoder = W3Target * distance;\n        int intW1Encoder = (int)Math.round(W1Encoder);\n        int intW2Encoder = (int)Math.round(W2Encoder);\n        int intW3Encoder = (int)Math.round(W3Encoder);\n\n        W1.setTargetPosition(intW1Encoder);\n        W2.setTargetPosition(intW2Encoder);\n        W3.setTargetPosition(intW3Encoder);\n        W1.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        W2.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        W3.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n\n        double proportion = Math.max(Math.max(Math.abs(W1Encoder), Math.abs(W2Encoder)), Math.max(Math.abs(W2Encoder), Math.abs(W3Encoder)));\n        W1.setPower(power * W1Encoder/ proportion);\n        W2.setPower(power * W2Encoder/ proportion);\n        W3.setPower(power * W3Encoder/ proportion);\n        //wait until the motors finish or time expires\n        //noinspection StatementWithEmptyBody\n        while ((W1.isBusy() || W2.isBusy() || W3.isBusy()) && timer.milliseconds() < timeout) {\n        }\n        stopDrive();\n    }\n\n    public void rotate (double targetRotation, double timeout, double power){\n        ElapsedTime timer = new ElapsedTime();\n        timer.reset();\n        double newAngle = Math.toRadians(targetRotation + 90);\n        double rotationInEncoderCounts = (newAngle / (2 * Math.PI)) * 1250;\n        int intRotationInEncoderCounts = (int)Math.round(rotationInEncoderCounts);\n        W1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        W2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        W3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        W1.setTargetPosition(intRotationInEncoderCounts);\n        W2.setTargetPosition(intRotationInEncoderCounts);\n        W3.setTargetPosition(intRotationInEncoderCounts);\n        W1.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        W2.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        W3.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        W1.setPower(power);\n        W2.setPower(power);\n        W3.setPower(power);\n        while ((W1.isBusy() || W2.isBusy() || W3.isBusy()) && timer.milliseconds() < timeout) {\n        }\n        stopDrive();\n    }\n\n    public void driveFront(double distance, double timeout, double power){\n        ElapsedTime timer = new ElapsedTime();\n        timer.reset();\n        //reset encoders\n        W1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        W2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        W3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        double W1Target = .58;\n        double W2Target = -.58;\n        double W3Target = 0;\n        double W1Encoder = W1Target * distance;\n        double W2Encoder = W2Target * distance;\n        double W3Encoder = W3Target * distance;\n        int intW1Encoder = (int)Math.round(W1Encoder);\n        int intW2Encoder = (int)Math.round(W2Encoder);\n        int intW3Encoder = (int)Math.round(W3Encoder);\n\n        W1.setTargetPosition(intW1Encoder);\n        W2.setTargetPosition(intW2Encoder);\n        W3.setTargetPosition(intW3Encoder);\n        W1.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        W2.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        W3.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n\n        double proportion = Math.max(Math.max(Math.abs(W1Target), Math.abs(W2Target)), Math.max(Math.abs(W2Target), Math.abs(W3Target)));\n        W1.setPower(power * W1Encoder/ proportion);\n        W2.setPower(power * W2Encoder/ proportion);\n        W3.setPower(power * W3Encoder/ proportion);\n        //wait until the motors finish or time expires\n        //noinspection StatementWithEmptyBody\n        while ((W1.isBusy() || W2.isBusy() || W3.isBusy()) && timer.milliseconds() < timeout) {\n        }\n        stopDrive();\n    }\n\n    public void driveFrontByMillimeters(double distanceInMillimeters, double timeout, double power){\n        ElapsedTime timer = new ElapsedTime();\n        timer.reset();\n        //reset encoders\n        double distance = distanceInMillimeters * 2.058575804;\n\n        W1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        W2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        W3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        double W1Target = 1;\n        double W2Target =-1;\n        double W3Target = 0;\n        double W1Encoder = W1Target * distance;\n        double W2Encoder = W2Target * distance;\n        double W3Encoder = W3Target * distance;\n        int intW1Encoder = (int)Math.round(W1Encoder);\n        int intW2Encoder = (int)Math.round(W2Encoder);\n        int intW3Encoder = (int)Math.round(W3Encoder);\n\n        W1.setTargetPosition(intW1Encoder);\n        W2.setTargetPosition(intW2Encoder);\n        W3.setTargetPosition(intW3Encoder);\n        W1.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        W2.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        W3.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n\n        double proportion = Math.max(Math.max(Math.abs(W1Target), Math.abs(W2Target)), Math.max(Math.abs(W2Target), Math.abs(W3Target)));\n        W1.setPower(power * W1Encoder/ proportion);\n        W2.setPower(power * W2Encoder/ proportion);\n        W3.setPower(power * W3Encoder/ proportion);\n        //wait until the motors finish or time expires\n        //noinspection StatementWithEmptyBody\n        while ((W1.isBusy() || W2.isBusy() || W3.isBusy()) && timer.milliseconds() < timeout) {\n        }\n        stopDrive();\n    }\n\n    public void stopDrive(){\n        W1.setPower(0);\n        W2.setPower(0);\n        W3.setPower(0);\n    }\n\n    public ParkingPosition getParkingPosition(){\n        return aprilTagPipeline.parkingPosition;\n    }\n\n\n\n\n}
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RobotHardware.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RobotHardware.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RobotHardware.java	
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RobotHardware.java	
@@ -164,8 +164,8 @@
         double time = loopTime*points.size();
 
 
-        PIDCoefficients positionPIDConstants = new PIDCoefficients(1, 0, 0);
-        PIDCoefficients velocityPIDConstants = new PIDCoefficients(1, 0, 0);
+        PIDCoefficients positionPIDConstants = new PIDCoefficients(0, 0, 0);
+        PIDCoefficients velocityPIDConstants = new PIDCoefficients(0, 0, 0);
 
         MotorPID W1PID = new MotorPID(W1, positionPIDConstants, velocityPIDConstants, telemetry);
         MotorPID W2PID = new MotorPID(W2, positionPIDConstants, velocityPIDConstants, telemetry);
