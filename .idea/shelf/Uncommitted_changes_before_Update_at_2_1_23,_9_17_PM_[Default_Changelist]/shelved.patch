Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/intake/Intake.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.intake;\n\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.roadrunner.control.PIDCoefficients;\nimport com.acmerobotics.roadrunner.control.PIDFController;\nimport com.acmerobotics.roadrunner.profile.MotionProfile;\nimport com.acmerobotics.roadrunner.profile.MotionProfileBuilder;\nimport com.acmerobotics.roadrunner.profile.MotionProfileGenerator;\nimport com.acmerobotics.roadrunner.profile.MotionSegment;\nimport com.acmerobotics.roadrunner.profile.MotionState;\nimport com.qualcomm.hardware.lynx.LynxModule;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\nimport com.qualcomm.robotcore.hardware.Servo;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\nimport com.qualcomm.robotcore.util.ElapsedTime;\n\nimport org.firstinspires.ftc.robotcore.external.Telemetry;\nimport org.firstinspires.ftc.teamcode.util.LynxModuleUtil;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n// https://github.com/NoahBres/VelocityPIDTuningTutorial/blob/master/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/SampleLinkedPIDUse.java\n@Config\npublic class Intake {\n    public static PIDCoefficients INTAKE_PID = new PIDCoefficients(.009, 0, 0.0002);\n    public static double kV = 0;\n    public static double kA = 0;\n    public static double kStatic = 0;\n    public static double kG = 0;\n\n    public static double MOTION_PROFILE_RECREATION_THRESHOLD = 5; // Only recreate the motion profile if target position changes by this many ticks\n\n    public static double MAX_LIFT_HEIGHT = 1800; // In ticks\n\n//    public static double GRAVITY_ACCEL = 5500; // Constant feedforward acceleration (in ticks/sec/sec) to counteract the lift\n    public static double MAX_VEL = 1000;\n    public static double MAX_ACCEL = 1000;\n    public static double MAX_JERK = 0;  // Jerk isn't used if it's 0, but it might end up being necessary\n\n    public ElapsedTime timer;\n\n    public DcMotorEx intake;\n    public Servo clawServo;\n\n    private PIDFController controller;\n    public MotionProfile motionProfile;\n\n    public double power = 0;\n\n    public Intake(HardwareMap hardwareMap) {\n        LynxModuleUtil.ensureMinimumFirmwareVersion(hardwareMap);\n\n        timer = new ElapsedTime();\n\n        intake = hardwareMap.get(DcMotorEx.class, \"intake\");\n        clawServo = hardwareMap.get(Servo.class, \"clawServo\");\n\n        intake.setDirection(DcMotor.Direction.REVERSE);\n        intake.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        intake.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        intake.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n\n        // Turns on bulk reading\n        for (LynxModule module : hardwareMap.getAll(LynxModule.class)) {\n            module.setBulkCachingMode(LynxModule.BulkCachingMode.AUTO);\n        }\n\n        controller = new PIDFController(INTAKE_PID, kV, kA, kStatic, (x, v) -> kG);\n        motionProfile = MotionProfileGenerator.generateSimpleMotionProfile(\n                new MotionState(intake.getCurrentPosition(), intake.getVelocity(), 0),\n                new MotionState(intake.getCurrentPosition(), 0, 0),\n                MAX_VEL,\n                MAX_ACCEL,\n                MAX_JERK\n        );\n    }\n\n    public void openClaw() {\n        clawServo.setPosition(1.0);\n    }\n    public void closeClaw(){\n        clawServo.setPosition(0.8);\n    }\n\n    public double getTargetPosition() {\n        return motionProfile.end().getX();\n    }\n\n    public boolean motionProfileHasReachedEnd() {\n        return timer.time() >= motionProfile.duration();\n    }\n\n    public void setTargetPosition(double targetPosition) {\n        // Add bounds so that the lift can not go too high or too low\n        if (targetPosition < 0) {\n            targetPosition = 0;\n        } else if (targetPosition > MAX_LIFT_HEIGHT) {\n            targetPosition = MAX_LIFT_HEIGHT;\n        }\n\n        if (Math.abs(motionProfile.end().getX() - targetPosition) < MOTION_PROFILE_RECREATION_THRESHOLD) {\n            return;\n        }\n\n        if (motionProfileHasReachedEnd()) {\n            motionProfile = MotionProfileGenerator.generateSimpleMotionProfile(\n                    new MotionState(intake.getCurrentPosition(), intake.getVelocity(), 0),\n                    new MotionState(targetPosition, 0, 0),\n                    MAX_VEL,\n                    MAX_ACCEL,\n                    MAX_JERK\n            );\n\n            timer.reset();\n        } else {\n            List<MotionSegment> allMotionSegments = motionProfile.getSegments();\n            List<MotionSegment> completedSegments = new ArrayList<>();\n            MotionState lastState = motionProfile.end();\n            double remainingTime = timer.time();\n            for (MotionSegment segment : allMotionSegments) {\n                // TODO: Check if last segment should be added or not\n                if (remainingTime <= segment.getDt()) {\n                    lastState = segment.get(remainingTime);\n                    break;\n                }\n                completedSegments.add(segment);\n                remainingTime -= segment.getDt();\n            }\n\n            motionProfile = MotionProfileGenerator.generateSimpleMotionProfile(\n                    lastState,\n                    new MotionState(targetPosition, 0, 0),\n                    MAX_VEL,\n                    MAX_ACCEL,\n                    MAX_JERK\n            );\n\n            if (completedSegments.size() > 0) {\n                MotionProfile completedProfile = new MotionProfile(completedSegments);\n                motionProfile = completedProfile.plus(motionProfile);\n            }\n        }\n    }\n\n    public void setRelativeTargetPosition(double deltaTargetPosition) {\n        double newTargetPosition = getTargetPosition() + deltaTargetPosition;\n        setTargetPosition(newTargetPosition);\n    }\n\n    public void followMotionProfile() {\n        MotionState state = motionProfile.get(timer.time());\n\n        controller.setTargetPosition(state.getX());\n        controller.setTargetVelocity(state.getV());\n        controller.setTargetAcceleration(state.getA());\n\n        power = controller.update(intake.getCurrentPosition(), intake.getVelocity());\n        intake.setPower(power);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/intake/Intake.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/intake/Intake.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/intake/Intake.java	(revision 0281adbdf6632d57aad4fcb4e45758c8e4dcaf38)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/intake/Intake.java	(date 1675280826081)
@@ -35,6 +35,9 @@
     public static double MAX_LIFT_HEIGHT = 1800; // In ticks
 
 //    public static double GRAVITY_ACCEL = 5500; // Constant feedforward acceleration (in ticks/sec/sec) to counteract the lift
+    public static double CLAW_CLOSED = -0.8;
+    public static double CLAW_OPENED = 0.8;
+
     public static double MAX_VEL = 1000;
     public static double MAX_ACCEL = 1000;
     public static double MAX_JERK = 0;  // Jerk isn't used if it's 0, but it might end up being necessary
@@ -78,10 +81,13 @@
     }
 
     public void openClaw() {
-        clawServo.setPosition(1.0);
+        clawServo.setPosition(CLAW_OPENED);
     }
     public void closeClaw(){
-        clawServo.setPosition(0.8);
+        clawServo.setPosition(CLAW_CLOSED);
+    }
+    public void clawUpdate(double CLAW_POSITION){
+        clawServo.setPosition(CLAW_POSITION);
     }
 
     public double getTargetPosition() {
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmode/Drive.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.opmode;\n\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.geometry.Vector2d;\nimport com.acmerobotics.roadrunner.profile.MotionState;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.Gamepad;\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.util.ElapsedTime;\n\nimport org.firstinspires.ftc.teamcode.intake.Intake;\nimport org.firstinspires.ftc.teamcode.drive.SampleOmniDrive;\nimport org.firstinspires.ftc.teamcode.intake.IntakeConstants;\n\n\n@Config\n@TeleOp\npublic class Drive extends OpMode {\n    public static double SLOW_MODE_SCALAR = 0.4;\n    public static double LIFT_MULTIPLIER = 1000; // TICKS/SEC. This num should be pretty close to MAX_VEL? If it's too far off, then when we stop moving the stick the lift will continue moving for a while after\n\n    // TODO: Remove, this is for debugging purpose\n    // private static Pose2d START_POSE = PoseStorage.currentPose;\n    private static Pose2d START_POSE = new Pose2d(36, -62.8, Math.toRadians(90));\n\n    private ElapsedTime timer;\n\n    private boolean driverSlowMode = false;\n    private Gamepad previousGamepad1 = new Gamepad();\n    private Gamepad previousGamepad2 = new Gamepad();\n\n    public SampleOmniDrive drive;\n    public Intake intake;\n\n    @Override\n    public void init() {\n        timer = new ElapsedTime();\n\n        drive = new SampleOmniDrive(hardwareMap);\n        intake = new Intake(hardwareMap);\n\n        drive.setPoseEstimate(START_POSE);\n    }\n\n    @Override\n    public void loop() {\n        // Enable toggling driver slow mode when press a\n        if (!previousGamepad1.a && gamepad1.a) {\n            driverSlowMode = !driverSlowMode;\n        }\n\n        // Create a vector from the gamepad x/y inputs\n        Vector2d translationalInput = new Vector2d(-gamepad1.left_stick_y, -gamepad1.left_stick_x);\n\n        // Read pose\n//        Pose2d poseEstimate = drive.getPoseEstimate();\n        // Then, rotate that vector by the inverse of the robots' DELTA heading for driver lock\n//        translationalInput = translationalInput.rotated(-(poseEstimate.getHeading() - START_POSE.getHeading()));\n\n        Pose2d input = new Pose2d(translationalInput, -gamepad1.right_stick_x);\n\n        if (driverSlowMode) {\n            input = input.times(SLOW_MODE_SCALAR);\n        }\n\n        // Pass in the rotated input + right stick value for rotation\n        drive.setWeightedDrivePower(input);\n\n        intake.setRelativeTargetPosition(-gamepad2.left_stick_y * LIFT_MULTIPLIER * timer.time());\n        timer.reset();\n\n        if (gamepad2.x){\n            intake.closeClaw();\n        }\n\n        if (gamepad2.y){\n            intake.openClaw();\n        }\n\n        if (!previousGamepad2.dpad_up && gamepad2.dpad_up) {\n            intake.setTargetPosition(IntakeConstants.HIGH_JUNCTION_HEIGHT);\n        }\n\n        if (!previousGamepad2.dpad_right && gamepad2.dpad_right) {\n            intake.setTargetPosition(IntakeConstants.MEDIUM_JUNCTION_HEIGHT);\n        }\n\n        if (!previousGamepad2.dpad_left && gamepad2.dpad_left) {\n            intake.setTargetPosition(IntakeConstants.LOW_JUNCTION_HEIGHT);\n        }\n\n        if (!previousGamepad2.dpad_down && gamepad2.dpad_down) {\n            intake.setTargetPosition(IntakeConstants.GROUND_JUNCTION_HEIGHT);\n        }\n\n        MotionState state = intake.motionProfile.get(intake.timer.time());\n        telemetry.addData(\"End X\", intake.getTargetPosition());\n        telemetry.addData(\"Reached End\", intake.motionProfileHasReachedEnd());\n        telemetry.addData(\"X\", state.getX());\n        telemetry.addData(\"V\", state.getV());\n        telemetry.addData(\"A\", state.getA());\n        telemetry.addData(\"Current X\", intake.intake.getCurrentPosition());\n        telemetry.addData(\"Current V\", intake.intake.getVelocity());\n        telemetry.addData(\"Power\", intake.power);\n\n        drive.update();\n        intake.followMotionProfile();\n\n        previousGamepad1.copy(gamepad1);\n        previousGamepad2.copy(gamepad2);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmode/Drive.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmode/Drive.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmode/Drive.java	(revision 0281adbdf6632d57aad4fcb4e45758c8e4dcaf38)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmode/Drive.java	(date 1675280826252)
@@ -45,6 +45,8 @@
 
     @Override
     public void loop() {
+       double servoTarget = 0;
+
         // Enable toggling driver slow mode when press a
         if (!previousGamepad1.a && gamepad1.a) {
             driverSlowMode = !driverSlowMode;
@@ -70,14 +72,6 @@
         intake.setRelativeTargetPosition(-gamepad2.left_stick_y * LIFT_MULTIPLIER * timer.time());
         timer.reset();
 
-        if (gamepad2.x){
-            intake.closeClaw();
-        }
-
-        if (gamepad2.y){
-            intake.openClaw();
-        }
-
         if (!previousGamepad2.dpad_up && gamepad2.dpad_up) {
             intake.setTargetPosition(IntakeConstants.HIGH_JUNCTION_HEIGHT);
         }
