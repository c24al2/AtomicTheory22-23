Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/intake/Intake.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.intake;\n\nimport com.acmerobotics.dashboard.FtcDashboard;\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.dashboard.telemetry.TelemetryPacket;\nimport com.acmerobotics.roadrunner.control.PIDCoefficients;\nimport com.acmerobotics.roadrunner.control.PIDFController;\nimport com.acmerobotics.roadrunner.profile.MotionProfile;\nimport com.acmerobotics.roadrunner.profile.MotionProfileBuilder;\nimport com.acmerobotics.roadrunner.profile.MotionProfileGenerator;\nimport com.acmerobotics.roadrunner.profile.MotionSegment;\nimport com.acmerobotics.roadrunner.profile.MotionState;\nimport com.qualcomm.hardware.lynx.LynxModule;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\nimport com.qualcomm.robotcore.hardware.Servo;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\nimport com.qualcomm.robotcore.util.ElapsedTime;\n\nimport org.firstinspires.ftc.robotcore.external.Telemetry;\nimport org.firstinspires.ftc.teamcode.util.LynxModuleUtil;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n// https://github.com/NoahBres/VelocityPIDTuningTutorial/blob/master/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/SampleLinkedPIDUse.java\n@Config\npublic class Intake {\n    public static PIDCoefficients INTAKE_PID = new PIDCoefficients(.009, 0, 0.0002);\n    public static double kV = 0;\n    public static double kA = 0;\n    public static double kStatic = 0;\n    public static double kG = 0;\n\n    public static double MOTION_PROFILE_RECREATION_THRESHOLD = 5; // Only recreate the motion profile if target position changes by this many ticks\n\n    public static double MAX_LIFT_HEIGHT = 1800; // In ticks\n\n   public static double GRAVITY_ACCEL = 5500; // Constant feedforward acceleration (in ticks/sec/sec) to counteract the lift\n    public static double CLAW_CLOSED = -0.8;\n    public static double CLAW_OPENED = 0.8;\n\n    public static double MAX_VEL = 1000;\n    public static double MAX_ACCEL = 1000;\n    public static final boolean RUN_USING_ENCODER = false;\n    public static double MAX_JERK = 0;  // Jerk isn't used if it's 0, but it might end up being necessary\n\n    public ElapsedTime timer;\n\n    public DcMotorEx intake;\n    public Servo clawServo;\n\n    public PIDFController controller;\n    public MotionProfile motionProfile;\n\n    public PIDFController downcontroller;\n    public MotionProfile downmotionProfile;\n    private final FtcDashboard dashboard;\n\n    public Intake(HardwareMap hardwareMap) {\n        LynxModuleUtil.ensureMinimumFirmwareVersion(hardwareMap);\n\n        timer = new ElapsedTime();\n\n        intake = hardwareMap.get(DcMotorEx.class, \"intake\");\n        clawServo = hardwareMap.get(Servo.class, \"clawServo\");\n\n        intake.setDirection(DcMotor.Direction.REVERSE);\n        intake.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        intake.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        intake.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n\n        // Turns on bulk reading\n        for (LynxModule module : hardwareMap.getAll(LynxModule.class)) {\n            module.setBulkCachingMode(LynxModule.BulkCachingMode.AUTO);\n        }\n\n        controller = new PIDFController(INTAKE_PID, kV, kA, kStatic);\n        motionProfile = MotionProfileGenerator.generateSimpleMotionProfile(\n                new MotionState(intake.getCurrentPosition(), intake.getVelocity(), 0),\n                new MotionState(intake.getCurrentPosition(), 0, 0),\n                MAX_VEL,\n                MAX_ACCEL,\n                MAX_JERK\n        );\n\n        downcontroller = new PIDFController(INTAKE_PID, kV, kA, kStatic);\n        downmotionProfile = MotionProfileGenerator.generateSimpleMotionProfile(\n                new MotionState(intake.getCurrentPosition(), intake.getVelocity(), GRAVITY_ACCEL),\n                new MotionState(intake.getCurrentPosition(), 0, 0),\n                MAX_VEL,\n                MAX_ACCEL,\n                MAX_JERK\n        );\n\n        dashboard = FtcDashboard.getInstance();\n        dashboard.setTelemetryTransmissionInterval(25);\n    }\n\n    public void openClaw() {\n        clawServo.setPosition(CLAW_OPENED);\n    }\n    public void closeClaw(){\n        clawServo.setPosition(CLAW_CLOSED);\n    }\n\n    public double getTargetPosition() {\n        return motionProfile.end().getX();\n    }\n\n    public boolean motionProfileHasReachedEnd() {\n        return timer.time() >= motionProfile.duration();\n    }\n\n    public void setTargetPosition(double targetPosition) {\n        // Add bounds so that the lift can not go too high or too low\n        if (targetPosition < 0) {\n            targetPosition = 0;\n        } else if (targetPosition > MAX_LIFT_HEIGHT) {\n            targetPosition = MAX_LIFT_HEIGHT;\n        }\n\n        if (Math.abs(motionProfile.end().getX() - targetPosition) < MOTION_PROFILE_RECREATION_THRESHOLD) {\n            return;\n        }\n\n        if (intake.getCurrentPosition() > targetPosition) {\n            if (motionProfileHasReachedEnd()) {\n                motionProfile = MotionProfileGenerator.generateSimpleMotionProfile(\n                        new MotionState(intake.getCurrentPosition(), intake.getVelocity(), -GRAVITY_ACCEL),\n                        new MotionState(targetPosition, 0, 0),\n                        MAX_VEL,\n                        MAX_ACCEL,\n                        MAX_JERK\n                );\n            }\n            if (intake.getCurrentPosition() < targetPosition) {\n                if (motionProfileHasReachedEnd()) {\n                    motionProfile = MotionProfileGenerator.generateSimpleMotionProfile(\n                            new MotionState(intake.getCurrentPosition(), intake.getVelocity(), 0),\n                            new MotionState(targetPosition, 0, 0),\n                            MAX_VEL,\n                            MAX_ACCEL,\n                            MAX_JERK\n                    );\n                }\n\n                timer.reset();\n            } else {\n                List<MotionSegment> allMotionSegments = motionProfile.getSegments();\n                List<MotionSegment> completedSegments = new ArrayList<>();\n                MotionState lastState = motionProfile.end();\n                double remainingTime = timer.time();\n                for (MotionSegment segment : allMotionSegments) {\n                    // TODO: Check if last segment should be added or not\n                    if (remainingTime <= segment.getDt()) {\n                        lastState = segment.get(remainingTime);\n                        break;\n                    }\n                    completedSegments.add(segment);\n                    remainingTime -= segment.getDt();\n                }\n\n                motionProfile = MotionProfileGenerator.generateSimpleMotionProfile(\n                        lastState,\n                        new MotionState(targetPosition, 0, 0),\n                        MAX_VEL,\n                        MAX_ACCEL,\n                        MAX_JERK\n                );\n\n                if (completedSegments.size() > 0) {\n                    MotionProfile completedProfile = new MotionProfile(completedSegments);\n                    motionProfile = completedProfile.plus(motionProfile);\n                }\n            }\n        }\n    }\n\n    public void setRelativeTargetPosition(double deltaTargetPosition) {\n        double newTargetPosition = getTargetPosition() + deltaTargetPosition;\n        TelemetryPacket packet = new TelemetryPacket();\n        packet.put(\"oldTargetPosition\", getTargetPosition());\n        packet.put(\"newTargetPosition\", newTargetPosition);\n        dashboard.sendTelemetryPacket(packet);\n        setTargetPosition(newTargetPosition);\n    }\n\n    public void followMotionProfile() {\n        MotionState state = motionProfile.get(timer.time());\n\n        controller.setTargetPosition(state.getX());\n        controller.setTargetVelocity(state.getV());\n        controller.setTargetAcceleration(state.getA());\n\n        double power = controller.update(intake.getCurrentPosition(), intake.getVelocity());\n        intake.setPower(power + kG);\n\n        TelemetryPacket packet = new TelemetryPacket();\n        packet.put(\"slideTime\", timer.time());\n        packet.put(\"slideX\", intake.getCurrentPosition());\n        packet.put(\"slideV\", intake.getVelocity());\n        packet.put(\"targetSlideX\", state.getX());\n        packet.put(\"targetSlideV\", state.getV());\n        packet.put(\"slidePower\", power);\n        dashboard.sendTelemetryPacket(packet);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/intake/Intake.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/intake/Intake.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/intake/Intake.java	(revision aabd44fece256fde3cad6e23ad3f1738c4f9b7dd)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/intake/Intake.java	(date 1675364798423)
@@ -37,8 +37,8 @@
     public static double MAX_LIFT_HEIGHT = 1800; // In ticks
 
    public static double GRAVITY_ACCEL = 5500; // Constant feedforward acceleration (in ticks/sec/sec) to counteract the lift
-    public static double CLAW_CLOSED = -0.8;
-    public static double CLAW_OPENED = 0.8;
+    public static double CLAW_CLOSED = 0.0;
+    public static double CLAW_OPENED = 1.0;
 
     public static double MAX_VEL = 1000;
     public static double MAX_ACCEL = 1000;
